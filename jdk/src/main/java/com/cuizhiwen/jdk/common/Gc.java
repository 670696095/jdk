package com.cuizhiwen.jdk.common;

/**
 * @author 01418061(cuizhiwen)
 * @Description:
 * @date 2019/1/3 10:50
 */
public class Gc {
    /**
     * 垃圾回收机制
     *           1>系统创建对象，数组等引用类型实体时，在堆内存中分配内存，当不再引用时这块内存就变成了垃圾。
     *           2>只回收内存中的对象，不会回收物理资源(数据库连接 网络IO)
     *  JVM 垃圾回收机制和常见算法
     *      理论上来讲 Sun 公司只定义了垃圾回收机制规则而不局限于其实现算法，因此不同厂商生产的虚拟机采用的算法也不尽相同。
     *          GC（Garbage Collector）在回收对象前首先必须发现那些无用的对象，如何去发现定位这些无用的对象？常用
     *          的搜索算法如下：
     *              1）引用计数器算法（废弃）
     *              引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，
     *              计数器-1，当计数器为 0 的时候，JVM 就认为对象不再被使用，是“垃圾”了。
     *              引用计数器实现简单，效率高；但是不能解决循环引用问问题（A 对象引用 B 对象，B 对象又引用 A 对象，但是
     *              A,B 对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在 JDK1.1 之后，
     *              这个算法已经不再使用了。
     *              2）根搜索算法（使用）
     *              根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链
     *              （Reference Chain），当一个对象没有被 GC Roots 的引用链连接的时候，说明这个对象是不可用的。
     *              GC Roots 对象包括：
     *               a) 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
     *               b) 方法区域中的类静态属性引用的对象。
     *               c) 方法区域中常量引用的对象。
     *               d) 本地方法栈中 JNI（Native 方法）的引用的对象。
     *              通过上面的算法搜索到无用对象之后，就是回收过程，回收算法如下：
     *                      1）标记—清除算法（Mark-Sweep）（DVM 使用的算法）
     *                      标记—清除算法包括两个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶段
     *                      紧随标记阶段，将标记阶段确定不可用的对象清除。标记—清除算法是基础的收集算法，标记和清除阶段的效率不高，
     *                      而且清除后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。
     *                      2）复制算法（Copying）
     *                      复制算法是把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，
     *                      然后把这块内存整个清理掉。复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率
     *                      不高。现在的 JVM 用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例
     *                      不是 1:1(大概是 8:1)。
     *                      3）标记—整理算法（Mark-Compact）
     *                      标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对
     *                      象往内存的一端移动，然后直接回收边界以外的内存。标记—整理算法提高了内存的利用率，并且它适合在收集对象
     *                      存活时间较长的老年代。
     *                      4）分代收集（Generational Collection）
     *                      分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃
     *                      圾回收算法。新生代采用复制算法，老年代采用标记—整理算法。垃圾算法的实现涉及大量的程序细节，而且不同的
     *                      虚拟机平台实现的方法也各不相同
     */
    public static void main(String[] args) {
        System.gc();
        Runtime.getRuntime().gc();
    }
}
