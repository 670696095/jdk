package com.cuizhiwen.jdk.common;

/**
 * @author 01418061(cuizhiwen)
 * @Description:
 * @date 2019/1/3 10:50
 */
public class Gc {
    /**
     * 垃圾回收机制
     *           1>系统创建对象，数组等引用类型实体时，在堆内存中分配内存，当不再引用时这块内存就变成了垃圾。
     *           2>只回收内存中的对象，不会回收物理资源(数据库连接 网络IO)
     *  JVM 垃圾回收机制和常见算法
     *      理论上来讲 Sun 公司只定义了垃圾回收机制规则而不局限于其实现算法，因此不同厂商生产的虚拟机采用的算法也不尽相同。
     *          GC（Garbage Collector）在回收对象前首先必须发现那些无用的对象，如何去发现定位这些无用的对象？常用
     *          的搜索算法如下：
     *              1）引用计数器算法（废弃）
     *              引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，
     *              计数器-1，当计数器为 0 的时候，JVM 就认为对象不再被使用，是“垃圾”了。
     *              引用计数器实现简单，效率高；但是不能解决循环引用问问题（A 对象引用 B 对象，B 对象又引用 A 对象，但是
     *              A,B 对象已不被任何其他对象引用），同时每次计数器的增加和减少都带来了很多额外的开销，所以在 JDK1.1 之后，
     *              这个算法已经不再使用了。
     *              2）根搜索算法（使用）
     *              根搜索算法是通过一些“GC Roots”对象作为起点，从这些节点开始往下搜索，搜索通过的路径成为引用链
     *              （Reference Chain），当一个对象没有被 GC Roots 的引用链连接的时候，说明这个对象是不可用的。
     *              GC Roots 对象包括：
     *               a) 虚拟机栈（栈帧中的本地变量表）中的引用的对象。
     *               b) 方法区域中的类静态属性引用的对象。
     *               c) 方法区域中常量引用的对象。
     *               d) 本地方法栈中 JNI（Native 方法）的引用的对象。
     *              通过上面的算法搜索到无用对象之后，就是回收过程，回收算法如下：
     *                      1）标记—清除算法（Mark-Sweep）（DVM 使用的算法）
     *                      标记—清除算法包括两个阶段：“标记”和“清除”。在标记阶段，确定所有要回收的对象，并做标记。清除阶段
     *                      紧随标记阶段，将标记阶段确定不可用的对象清除。标记—清除算法是基础的收集算法，标记和清除阶段的效率不高，
     *                      而且清除后回产生大量的不连续空间，这样当程序需要分配大内存对象时，可能无法找到足够的连续空间。
     *                      2）复制算法（Copying）
     *                      复制算法是把内存分成大小相等的两块，每次使用其中一块，当垃圾回收的时候，把存活的对象复制到另一块上，
     *                      然后把这块内存整个清理掉。复制算法实现简单，运行效率高，但是由于每次只能使用其中的一半，造成内存的利用率
     *                      不高。现在的 JVM 用复制方法收集新生代，由于新生代中大部分对象（98%）都是朝生夕死的，所以两块内存的比例
     *                      不是 1:1(大概是 8:1)。
     *                      3）标记—整理算法（Mark-Compact）
     *                      标记—整理算法和标记—清除算法一样，但是标记—整理算法不是把存活对象复制到另一块内存，而是把存活对
     *                      象往内存的一端移动，然后直接回收边界以外的内存。标记—整理算法提高了内存的利用率，并且它适合在收集对象
     *                      存活时间较长的老年代。
     *                      4）分代收集（Generational Collection）
     *                      分代收集是根据对象的存活时间把内存分为新生代和老年代，根据各个代对象的存活特点，每个代采用不同的垃
     *                      圾回收算法。新生代采用复制算法，老年代采用标记—整理算法。垃圾算法的实现涉及大量的程序细节，而且不同的
     *                      虚拟机平台实现的方法也各不相同
     *  Java 的 GC 什么时候回收垃圾（2017-11-16-wl）
     * 在面试中经常会碰到这样一个问题（事实上笔者也碰到过）：如何判断一个对象已经死去？
     * 很容易想到的一个答案是：对一个对象添加引用计数器。每当有地方引用它时，计数器值加 1；当引用失效时，计
     * 数器值减 1.而当计数器的值为 0 时这个对象就不会再被使用，判断为已死。是不是简单又直观。然而，很遗憾。这种
     * 做法是错误的！为什么是错的呢？事实上，用引用计数法确实在大部分情况下是一个不错的解决方案，而在实际的应
     * 用中也有不少案例，但它却无法解决对象之间的循环引用问题。比如对象 A 中有一个字段指向了对象 B，而对象 B 中
     * 也有一个字段指向了对象 A，而事实上他们俩都不再使用，但计数器的值永远都不可能为 0，也就不会被回收，然后就
     * 发生了内存泄露。
     * 所以，正确的做法应该是怎样呢？
     * 在 Java，C#等语言中，比较主流的判定一个对象已死的方法是：可达性分析(Reachability Analysis).
     * 所有生成的对象都是一个称为"GC Roots"的根的子树。从 GC Roots 开始向下搜索，搜索所经过的路径称为引用链
     * (Reference Chain)，当一个对象到 GC Roots 没有任何引用链可以到达时，就称这个对象是不可达的（不可引用的），
     * 也就是可以被 GC 回收了。
     * 无论是引用计数器还是可达性分析，判定对象是否存活都与引用有关！那么，如何定义对象的引用呢？
     * 我们希望给出这样一类描述：当内存空间还够时，能够保存在内存中；如果进行了垃圾回收之后内存空间仍旧非
     * 常紧张，则可以抛弃这些对象。所以根据不同的需求，给出如下四种引用，根据引用类型的不同，GC 回收时也会有不
     * 同的操作：
     * 1)强引用(Strong Reference):Object obj = new Object();只要强引用还存在，GC 永远不会回收掉被引用的对象。
     * 2)软引用(Soft Reference)：描述一些还有用但非必需的对象。在系统将会发生内存溢出之前，会把这些对象列入
     * 回收范围进行二次回收（即系统将会发生内存溢出了，才会对他们进行回收。）
     * 弱引用(Weak Reference):程度比软引用还要弱一些。这些对象只能生存到下次 GC 之前。当 GC 工作时，无论内
     * 存是否足够都会将其回收（即只要进行 GC，就会对他们进行回收。）
     * 虚引用(Phantom Reference):一个对象是否存在虚引用，完全不会对其生存时间构成影响。
     * 关于方法区中需要回收的是一些废弃的常量和无用的类。
     * 1.废弃的常量的回收。这里看引用计数就可以了。没有对象引用该常量就可以放心的回收了。
     * 2.无用的类的回收。什么是无用的类呢？
     * A.该类所有的实例都已经被回收。也就是 Java 堆中不存在该类的任何实例；
     * B.加载该类的 ClassLoader 已经被回收；
     * C.该类对应的 java.lang.Class 对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。
     * 总而言之:
     * 对于堆中的对象，主要用可达性分析判断一个对象是否还存在引用，如果该对象没有任何引用就应该被回收。而
     * 根据我们实际对引用的不同需求，又分成了 4 中引用，每种引用的回收机制也是不同的。
     * 对于方法区中的常量和类，当一个常量没有任何对象引用它，它就可以被回收了。而对于类，如果可以判定它为无
     * 用类，就可以被回收了
     */
    public static void main(String[] args) {
        System.gc();
        Runtime.getRuntime().gc();
    }
}
