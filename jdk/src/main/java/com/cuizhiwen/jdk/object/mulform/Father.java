package com.cuizhiwen.jdk.object.mulform;

/**
 * @author 01418061(cuizhiwen)
 * @Description:
 * @date 2019/1/4 16:37
 */
public abstract class  Father {
    /**
     * 多态性：
     *      多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。
     *      Java 中实现多态的机制是什么？
     *          靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，
     * 多态性分为
     *      1.编译时多态性 2.运行时的多态性。
     *       如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：当 A 系统访问 B 系统提供的服务时，B 系统有多种提供服务的方式，但一切对 A 系统来说都是透明的。
     *        A.方法重载（overload）实现的是编译时的多态性（也称为前绑定）
     *              重载发生在一个类中，同名的方法如果有不同的参数列表（参数类型不同、参数个数不同或者二者都不同）则视为重载
     *        B.方法重写（override）实现的是运行时的多态性（也称为后绑定）。
     *              重写发生在子类与父类之间，重写要求子类被重写方法与父类被重写方法有相同的返回类型，比父类被重写方法更好访问，不能比父类被重写方法声明更多的异常（里氏代换原则）。
     *
     *        运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
     *               1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
     *               2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法就会根据子类对象的不同而表现出不同的行为）
     * 重载/重写规则
     *      方法重载的规则：
     *          1.方法名一致，参数列表中参数的顺序，类型，个数不同。
     *          2.重载与方法的返回值无关，存在于同类中。
     *          3.可以抛出不同的异常，可以有不同修饰符。
     *      方法重写的规则：
     *          1.参数列表必须完全与被重写方法的一致，返回类型必须完全与被重写方法的返回类型一致。
     *          2.构造方法不能被重写，声明为 final 的方法不能被重写，声明为 static 的方法不能被重写，但是能够被再次声明。
     *          3.访问权限不能比父类中被重写的方法的访问权限更低。
     *          4.重写的方法能够抛出任何非强制异常（UncheckedException，也叫非运行时异常），无论被重写的方法是
     *          否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以
     */
    protected String name="父亲属性";

    public void method() {
        System.out.println("父类方法，对象类型：" + this.getClass());
    }

    public Father(String name) {
        this.name = name;
    }
     public    void testStatic(){

     }
}
