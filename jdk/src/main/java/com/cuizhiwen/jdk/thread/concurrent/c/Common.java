package com.cuizhiwen.jdk.thread.concurrent.c;

/**
 * @author 01418061(cuizhiwen)
 * @Description:
 * @date 2019/2/25 9:29
 */
public class Common {
    /**
     * C. 并发（Collection）队列-------非阻塞队列
     *      ➢非阻塞队列
     *      首先我们要简单的理解下什么是非阻塞队列：
     *      与阻塞队列相反，非阻塞队列的执行并不会被阻塞，无论是消费者的出队，还是生产者的入队。
     *      在底层，非阻塞队列使用的是 CAS(compare and swap)来实现线程执行的非阻塞。
     *          与阻塞队列相同，非阻塞队列中的常用方法，也是出队和入队。
     *          入队方法：
     *           add()：底层调用 offer();
     *           offer()：Queue 接口继承下来的方法，实现队列的入队操作，不会阻碍线程的执行，插入成功返回 true；
     *          出队方法：
     *           poll()：移动头结点指针，返回头结点元素，并将头结点元素出队；队列为空，则返回 null；
     *           peek()：移动头结点指针，返回头结点元素，并不会将头结点元素出队；队列为空，则返回 null；
     *      ➢非阻塞算法 CAS
     *          首先我们需要了解悲观锁和乐观锁
     *          悲观锁：假定并发环境是悲观的，如果发生并发冲突，就会破坏一致性，所以要通过独占锁彻底禁止冲突发
     *          生。有一个经典比喻，“如果你不锁门，那么捣蛋鬼就回闯入并搞得一团糟”，所以“你只能一次打开门放进
     *          一个人，才能时刻盯紧他”。
     *          乐观锁：假定并发环境是乐观的，即，虽然会有并发冲突，但冲突可发现且不会造成损害，所以，可以不加任
     *          何保护，等发现并发冲突后再决定放弃操作还是重试。可类比的比喻为，“如果你不锁门，那么虽然捣蛋鬼会
     *          闯入，但他们一旦打算破坏你就能知道”，所以“你大可以放进所有人，等发现他们想破坏的时候再做决定”。
     *          通常认为乐观锁的性能比悲观所更高，特别是在某些复杂的场景。这主要由于悲观锁在加锁的同时，也会把
     *          某些不会造成破坏的操作保护起来；而乐观锁的竞争则只发生在最小的并发冲突处，如果用悲观锁来理解，
     *          就是“锁的粒度最小”。但乐观锁的设计往往比较复杂，因此，复杂场景下还是多用悲观锁。
     *          首先保证正确性，有必要的话，再去追求性能。
     *      CAS
     *          乐观锁的实现往往需要硬件的支持，多数处理器都都实现了一个 CAS 指令，实现“Compare And Swap”的
     *          语义（这里的 swap 是“换入”，也就是 set），构成了基本的乐观锁。
     *          CAS 包含 3 个操作数：
     *           需要读写的内存位置 V
     *           进行比较的值 A
     *           拟写入的新值 B
     *          当且仅当位置 V 的值等于 A 时，CAS 才会通过原子方式用新值 B 来更新位置 V 的值；否则不会执行任何操
     *          作。无论位置 V 的值是否等于 A，都将返回 V 原有的值。
     *          一个有意思的事实是，“使用 CAS 控制并发”与“使用乐观锁”并不等价。CAS 只是一种手段，既可以实现
     *          乐观锁，也可以实现悲观锁。乐观、悲观只是一种并发控制的策略。下文将分别用 CAS 实现悲观锁和乐观锁？
     */
}
