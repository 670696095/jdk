package com.cuizhiwen.jdk.thread;

/**
 * @author 01418061(cuizhiwen)
 * @Description:
 * @date 2019/1/23 9:44
 */
public class Volatile {
    /**
     * Volatile关键字:
     *
     *      大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。
     *      由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，
     *      而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，
     *      因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。
     * 　　 也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，
     *     那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。
     *volatile关键字的两层语义
     * 　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：
     * 　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
     * 　　2）禁止进行指令重排序。
     *
     * 缓存不一致:
     *      如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。
     *      解决办法:
     *      1）通过在总线加LOCK#锁的方式
     *      2）通过缓存一致性协议
     * 　　 这2种方式都是硬件层面上提供的方式。
     * 共享变量:
     *      被多个线程访问的变量为共享变量。
     *
     *  并发编程三个问题：原子性问题，可见性问题，有序性问题
     *      原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
     *      可见性:是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
     *      有序性：即程序执行的顺序按照代码的先后顺序执行。
     *      指令重排序：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，
     *                但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
     *
     *      注意:要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。
     *  jvm内存模型:
     *      1>Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，
     *        以实现让Java程序在各种平台下都能达到一致的内存访问效果。
     *      2>Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。
     *        也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。
     *      3>Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。
     *        线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。
     *      原子性:
     *          1)只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。
     *          2)Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。
     *      可见性:
     *          1)对于可见性，Java提供了volatile关键字来保证可见性。
     *          2)当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
     *          3)而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。
     *          4)另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。
     *       有序性:
     *          1)在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
     *          2)在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，
     *          很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。
     *  happens-before 原则：
     *          Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。
     *          如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。
     *          1)程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作
     *          2)锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作
     *          3)volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作
     *          4)传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C
     *          5)线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作
     *          6)线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
     *          7)线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行
     *          8)对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始
     * valatile 可以保证可见性 有序性  不能保证原子性
     * valatile和Synchronized:
     *          synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，
     *          但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：
     * 　　           1）对变量的写操作不依赖于当前值
     *               2）该变量没有包含在具有其他变量的不变式中
     *
     *  2. volatile
     * 词义：易变的
     *      volatile也是变量修饰符，只能用来修饰变量。volatile修饰的成员变量在每次被线程访问时，都强迫从共享内存中重读该成员变量的值。而且，
     *      当成员变量发生变化时，强迫线程将变化值回写到共享内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。
     *      在此解释一下Java的内存机制：
     *      Java使用一个主内存来保存变量当前值，而每个线程则有其独立的工作内存。线程访问变量的时候会将变量的值拷贝到自己的工作内存中，这样，
     *      当线程对自己工作内存中的变量进行操作之后，就造成了工作内存中的变量拷贝的值与主内存中的变量值不同。
     *      Java语言规范中指出：为了获得最佳速度，允许线程保存共享成员变量的私有拷贝，而且只当线程进入或者离开同步代码块时才与共享成员变量的原始值对比。
     *      这样当多个线程同时与某个对象交互时，就必须要注意到要让线程及时的得到共享成员变量的变化。
     *      而volatile关键字就是提示VM：对于这个成员变量不能保存它的私有拷贝，而应直接与共享成员变量交互。
     *
     *      对于volatile类型的变量，系统每次用到他的时候都是直接从对应的内存当中提取，而不会利用cache当中的原有数值，以适应它的未知何时会发生的变化，
     *      系统对这种变量的处理不会做优化——显然也是因为它的数值随时都可能变化的情况。
     *
     * 使用建议：
     *       在两个或者更多的线程访问的成员变量上使用volatile。当要访问的变量已在synchronized代码块中，或者为常量时，不必使用。
     *       由于使用volatile屏蔽掉了VM中必要的代码优化，所以在效率上比较低，因此一定在必要时才使用此关键字。
     * 3. synchronized 和 volatile 关键字的作用
     *      一旦一个共享变量（类的成员变量、类的静态成员变量）被 volatile 修饰之后，那么就具备了两层语义：
     *          1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
     *          2）禁止进行指令重排序。
     *      volatile 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取；
     *      synchronized 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。
     *          1.volatile 仅能使用在变量级别；
     *          synchronized 则可以使用在变量、方法、和类级别的
     *          2.volatile 仅能实现变量的修改可见性，并不能保证原子性；
     *          synchronized 则可以保证变量的修改可见性和原子性
     *          3.volatile 不会造成线程的阻塞；
     *          synchronized 可能会造成线程的阻塞。
     *          4.volatile 标记的变量不会被编译器优化；
     *          synchronized 标记的变量可以被编译器优化
     */

    public volatile int inc = 0;

    static volatile boolean stop = true;

    public void increase() {
        inc++;
    }

    public static void main(String[] args) {
        //线程1
        while(!stop){
            doSomething();
        }
        //线程2
        stop = true;


        final Volatile test = new Volatile();
        for(int i=0;i<10;i++){
            new Thread(){
                @Override
                public void run() {
                    for(int j=0;j<1000;j++) {
                        test.increase();
                    }
                };
            }.start();
        }
        //保证前面的线程都执行完
        while(Thread.activeCount()>1)
        {
            Thread.yield();
            System.out.println(test.inc);
        }


    }

    private static void doSomething(){
        System.out.println("啥。。。");
    }
}
